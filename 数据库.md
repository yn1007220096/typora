







# sql 

| 命令   | 说明   | 例子 |
| ------ | ------ | ---- |
| create | 创建表 |      |
|        |        |      |
|        |        |      |
|        |        |      |



## ddl

### create

```
CREATE TABLE `` (
`id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键',
`` varchar(32) NOT NULL COMMENT '’,
`` int(4) NOT NULL COMMENT ‘’,
`` varchar(32) DEFAULT NULL COMMENT ‘‘,
`` datetime DEFAULT NULL COMMENT '',
PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=10060 DEFAULT CHARSET=utf8 COMMENT=‘';
```



## 函数





### concat

```
concat函数有一个特点就是有一个值为null那么不管第二个字符有多少内容都返回为空了
IFNULL(name,"") : 如果 name 为 null 用""代替
```

## 分页

```java
int start = (pageNo - 1) * pageSize;
```

```xml
select * from (
        select t.* , concat(ci.name ,'(',ci.cname,')' ) as app_name,ci.name as app_ename,ci.cname as app_cname from(

            select concat(ci.name ,'(',ci.cname,')' ) as interface_name,ci.name,ci.cname ,ci.desc ,hi.parent_id
            from component_info ci left join hierarchy_info hi on ci.id = hi.component_id
            where ci.yn = 1 and
            ci.compontent_type_id = 2
            and ci.id in ( select  distinct pi.component_id from provider_info pi  where pi.erp= #{erp} and pi.yn=1  )
            and hi.yn=1

        ) t left join component_info ci on t.parent_id = ci.id
       where ci.yn =1

    ) t1 where 1=1
    <if test="name != null and name != ''">
      and (t1.name like  concat('%',#{name},'%') or t1.cname like concat('%',#{name},'%') or t1.interface_name like  concat('%',#{name},'%'))
    </if>

    <if test="app != null and app != ''">
      and (t1.app_name like  concat('%',#{app},'%') or t1.app_ename like concat('%',#{app},'%') or t1.app_cname like  concat('%',#{app},'%'))
    </if>
    limit #{start},#{pageSize}
```





# 问题

## 1.测试连接数据库  Server returns invalid timezone. Need to set 'serverTimezone' property.

```
在Advanced 选项中 添加 name 和 value serverTimezone　　CST
```



# 题

数据库怎么设计？

满足三大范式



而在 MySQL中每个表的设计都可以采用不同的存储引擎，可以根据实际的数据处理需要来选择存储引擎，这也是 MySQL 的强大之处。

- InnoDB ：它是 MySQL 5.5 版本之后默认的存储引擎，最大的特点是支持事务、行级锁定、外键约束等。

- MyISAM ： MySQL 5.5 版本之前默认的存储引擎，不支持事务，也不支持外键，最大的特点是速度快，占用资源少。

- Memory :使用系统内存作为存储介质，以便得到更快的响应速度。不过如果 mysqld 进程崩溃，则会导致所有数据丢失，因此只有数据是临时情况下才使用 

- NDB:也叫做 NDB Cluster 存储引擎，主要用于 MySQL Cluster 分布式集群环境，类似于 Oracle 的RAC 集群

- Archive:：有很好的压缩机制，用于文件归档，在请求写入时会进行压缩，所以也经常用来做仓库。

  需要注意的是，数据库的设计在于表的设计，而在 MySQL中每个表的设计都可以采用不同的存储引擎，可以根据实际的数据处理需要来选择存储引擎，这也是 MySQL 的强大之处。

可以想一种业务场景



MySQL 的存储引擎是一大特色，其中 MyISAM 和 InnoDB 都是常用的存储 引擎，这两个搜索引擎的特性和使用场景分别是什么？



int(11) 没太大意义

数据库约束 和 代码约束？

实际业务怎么调优？

什么是全文索引？



## 1. 数据库的隔离级别 

首先用通俗的语言介绍以下事务（是[数据库管理系统](https://baike.baidu.com/item/数据库管理系统)执行过程中的一个逻辑单位，由一个有限的[数据库](https://baike.baidu.com/item/数据库)操作序列构成）的特性（ACID）：

  原子性（Atomicity）：一个事务中的操作，要么全部成功，要么全部失败，如果失败，就回滚到事务开始前的状态。

  一致性（Consistency）：事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。那转账举栗子，A账户和B账户之间相互转账，无论如何操作，A、B账户的总金额都必须是不变的。

  隔离性（Isolation）：当多个用户并发的访问数据库时，如果操作同一张表，数据库则为每一个用户都开启一个事务，且事务之间互不干扰，也就是说事务之间的并发是隔离的。再举个栗子，现有两个并发的事务T1和T2，T1要么在T2开始前执行，要么在T2结束后执行，如果T1先执行，那T2就在T1结束后在执行。关于数据的隔离性级别，将在后文讲到。

  持久性（Durability）：如果事务一旦被提交，数据库中数据的改变就是永久性的，即使断电或者宕机的情况下，也不会丢失提交的事务操作。

事务的隔离性：多个用户的并发事务访问同一个数据库时，一个用户的事务不应该被其他用户的事务干扰，多个并发事务之间要相互隔离。

如果不考虑隔离性，会发生什么事呢？

  1.脏读：一个事务在处理数据的过程中，读取到另一个未提交事务的数据。

  2.不可重复读：对于数据库中的某个数据，一个事务范围内的多次查询却返回了不 同的结果，这是由于在查询过程中，数据被另外一个事务修改并提交了。   

不可重复读和脏读的区别：脏读读取到的是一个未提交的数据，不可重复读读取到的是前一个事务提交的数据。

而不可重复读在一些情况也并不影响数据的正确性，比如需要多次查询的数据也是要以最后一次查询到的数据为主。

  3.幻读：事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。

幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。

不可重复读和幻读是初学者不易分清的概念，我也是看了详细的解读才明白的，总的来说，**解决不可重复读的方法是锁行，解决幻读的方式是锁表。**

四种隔离级别解决了上述问题

  1.读未提交（Read uncommitted）：这种事务隔离级别下，select语句不加锁。此时，可能读取到不一致的数据，即“读脏 ”。这是并发最高，一致性最差的隔离级别。

  2.读已提交（Read committed）：可避免脏读的发生。这是一致性最好的，但并发性最差的隔离级别。在互联网大数据量，高并发量的场景下，几乎 不会使用 上述两种隔离级别。

  3.可重复读（Repeatable read）：MySql默认隔离级别。可避免脏读 、不可重复读 的发生。

  4.串行化（Serializable ）：可避免脏读、不可重复读、幻读的发生。

以上四种隔离级别最高的是 Serializable 级别，最低的是 Read uncommitted 级别，当然级别越高，执行效率就越低。像 Serializable 这样的级别，就是以锁表的方式(类似于Java多线程中的锁)使得其他的线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况。在MySQL数据库中默认的隔离级别为Repeatable read (可重复读) 。

在MySQL数据库中，支持上面四种隔离级别，默认的为Repeatable read (可重复读) ；而在 Oracle数据库 中，只支持Serializable (串行化) 级别和 Read committed (读已提交) 这两种级别，其中默认的为 Read committed（读已提交） 级别。

## 2. 存储引擎

不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以获得特定的功能。现在许多不同的数据库管理系统都支持多种不同的数据引擎。

因为在关系数据库中数据的存储是以表的形式存储的，所以存储引擎也可以称为表类型(Table Type，即存储和操作此表的类型)。

### 1.Mysql中的myisam与innodb区别

- InooDB支持事务，而MyISAM不支持
- InnoDB支持行级锁，而MyISAM支持表级锁
- InnoDB支持MVCC，而MyISAM不支持；
- InnoDB支持外键，而MyISAM不支持；
- InnoDB不支持全文索引，而MyISAM支持；
- InnoDB不能通过直接拷贝表文件的方法拷贝表到另外一台机器， myisam 支持；
- InnoDB表支持多种行格式，myisam 不支持；
- InnoDB是索引组织表，myisam 是堆表；

### 2.myisam与innodb select count(*)哪个更快

myisam更快，因为myisam内部维护了一个计数器，可以直接调取。

### 3.行级锁和表级锁

相对其他数据库而言，MySQL的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。比如，MyISAM和MEMORY存储引擎采用的是表级锁（table-level locking）；InnoDB存储引擎既支持行级锁（ row-level locking），也支持表级锁，但默认情况下是采用行级锁。


 表级锁： 开销小，加锁快；不会出现死锁(因为MyISAM会一次性获得SQL所需的全部锁)；锁定粒度大，发生锁冲突的概率最高,并发度最低。
 行级锁： 开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。

考虑上述特点，表级锁使用与并发性不高，以查询为主，少量更新的应用，比如小型的web应用；而行级锁适用于高并发环境下，对事务完整性要求较高的系统，如在线事务处理系统。

 

## 3. 索引

索引(Index)是一种数据结构， 可以简单理解为：**快速查找排好序的一种数据结构**，  帮助MySQL快速检索数据

####  数据结构

  B+Tree索引和Hash索引。平常说的索引，如果没有特别指明，一般都是指B树结构组织的索引(B+Tree索引)

 #### 类型

- 普通索引：最基本的索引，没有任何限制
- 唯一索引：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一
- 主键索引：一种特殊的唯一索引，一个表只能有一个主键，不允许有空值
- 组合索引：多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀集合；多列值组成一个索引，专门用于组合搜索，其效率大于索引合并
- 全文索引：主要用来查找文本中的关键字，而不是直接与索引中的值相比较

#### 为什么能优化慢查询

索引其实就是一种优化查询的数据结构，比如Mysql中的索引是用B+树实现的，而B+树就是一种数据结构，可以优化查询速度，可以利用索引快速查找数据，所以能优化查询。

#### 数据库索引有哪些，优缺点

hash索引和B+树索引
B+树索引：数据有序，能够进行范围查询

哈希表适合等值查询（因为哈希索引底层是哈希表，哈希表是一种key-value存储数据的结构）

哈希索引没办法利用索引完成排序 ,因此不能进行范围查询

哈希索引不支持多列联合索引的最左匹配规则 

如果有大量重复键值的情况下，哈希索引的效率会很低，因为存在哈希碰撞问题

#### 为什么不用二叉查找树作为数据库索引？

二叉查找树，查找到指定数据，效率其实很高logn。查询速度和比较次数都是较小的。

实际上，查询索引操作最耗资源的不在内存中，而是磁盘IO。数据库索引文件有可能很大，关系型数据存储了上亿条数据，索引文件大则上G，不可能全部放入内存中，而是需要的时候换入内存，方式是磁盘页。一般来说树的一个节点就是一个磁盘页。如果使用二叉查找树，那么每个节点存储一个元素，查找到指定元素，需要进行大量的磁盘IO，效率很低。而B树解决了这个问题，通过单一节点包含多个data，大大降低了树的高度，大大减少了磁盘IO次数。

### 5. B树

​                               

B 树是为了磁盘或其它存储设备而设计的一种**多叉平衡查找树**。

　　B-树是一种平衡多路查找树，它在文件系统中很有用。一棵m阶B-树（图为4阶B-树），具有下列性质：
 （1）树中每个节点至多有m棵子树；
 （2）若根节点不是叶子节点，则至少有2棵子树；
 （3）除根节点之外的所有非终端节点至少有  棵子树；
 （4）每个节点中的信息结构为（A0,K1,A1,K2......Kn,An），其中n表示关键字个数，Ki为关键字，Ai为指针；
 （5）所有的叶子节点都出现在同一层次上，且不带任何信息，也是为了保持算法的一致性。

### 6. B+树

  （图e）

B+Tree是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。

B+数是B-树的一种变形，它与B-树的差别在于（图e为3阶B+树）：
 （1）有n棵子树的节点含有n个关键字；
 （2）所有的叶子节点包含了全部关键字的信息，及指向这些关键字记录的指针，且叶子节点本身按关键字大小自小到大顺序链接；
 （3）所有非终端节点可以看成是索引部分，节点中仅含有其子树（根节点）中最大（或最小）关键字，所有B+树更像一个索引顺序表；
 （4）对B+树进行查找运算，一是从最小关键字起进行顺序查找，二是从根节点开始，进行随机查找。

\7. 那么，如果在firstname、lastname、age这三个列上分别创建单列索引，效果是否和创建一个firstname、lastname、age的多列索引一样呢？答案是否定的，两者完全不同。当我们执行查询的时候，MySQL只能使用一个索引。如果你有三个单列的索引，MySQL会试图选择一个限制最严格的索引。但是，即使是限制最严格的单列索引，它的限制能力也肯定远远低于firstname、lastname、age这三个列上的多列索引。

### 8. 索引的缺点

\1. 索引要占用磁盘空间。通常情况下，这个问题不是很突出。但是，如果你创建每一种可能列组合的索引，索引文件体积的增长速度将远远超过数据文件。如果你有一个很大的表，索引文件的大小可能达到操作系统允许的最大文件限制。 

 2.对于需要写入数据的操作，比如DELETE、UPDATE以及INSERT操作，索引会降低它们的速度。这是因为MySQL不仅要把改动数据写入数据文件，而且它还要把这些改动写入索引文件。 

**9.****哪种情况需要创建索引**
 　1.主键自动建立唯一索引
 　2.频繁作为查询条件的字段应该创建索引
 　3.查询中与其他表关联的字段,外键关系建立索引

 　5.Where条件里用得到的字段适合创建索引
 　6.单键/组合索引的选择问题,在高并发下倾向创建组合索引
 　7.查询中排序的字段,排序字段若通过索引去访问将大大提高排序速度
 　8.查询中统计或者分组字段
 10哪种情况不需要建索引
 　1.表记录太少(一般生产环境下,三百万条记录性能就可能开始下降,官方说的是五百万到八百万)
 　2.经常增删改的表
 　3.某个数据列的值包含许多重复的内容

### 12一个B+树的节点中到底存储多少个元素合适呢？

　　B+树中一个节点为一页或页的倍数最为合适。因为如果一个节点的大小小于1页，那么读取这个节点的时候其实也会读出1页，会造成资源的浪费；如果一个节点的大小大于1页，比如1.2页，那么读取这个节点的时候会读出2页，也会造成资源的浪费；所以为了不造成资源的浪费，最后把一个节点的大小控制在1页、2页、3页、4页等倍数页大小最为合适！

### 11.哪些数据结构能提高查询速度？MySQL为何选择使用B+树？

哈希表、完全平衡二叉搜索树、B树、B+树等等；

哈希表的特点就是可以快速的精确查询，但是不支持范围查询

完全平衡二叉搜索树是有序的，简单的说就是 "左边的小于右边的"，假如我们现在来查找 '周瑜' ，需要查找2次（第一次操作，第二次周瑜），**比哈希表要多一次。而且由于完全平衡二叉搜索树是有序的，所以支持范围查找**。

B树表示的要比完全平衡二叉搜索树要 "矮",原因在于B树中的一个节点可以存储多个元素！

我们可以发现同样的元素，B+树的表示要比B树要 "胖"，原因在于B+树中的非叶子节点会冗余一份在叶子节点中，并且叶子节点之间用指针相连！

### 13.MySQL中B+树的一个节点大小为多大？

　　一页，这里说的 "页" 是MySQL自定义的单位（其实和操作系统类似），MySQL的Innodb引擎中一页的默认大小是16K（如果操作系统中一页大小是4K，那么MySQL中1页 = 操作系统中的4页），这样存取数据的时候都是一页一页的获取索引文件中节点数据的！

### 14一系列问题

\1. 系统中某个sql查询比较慢，怎么办？

 看条件字段是否加索引，若没加可以加索引

\2. mysql存储索引用什么数据结构？

 B+树

\3. B+树查询时间大约是多少？

 和树的高度有关，log(n)

\4. 如果用hash存储索引，查询时间？

O(1)

\5. hash比B+快，为啥不用hash

  如果只选一条 hash快，但实际数据库经常选多条。时候由于B+树索引有序，并且又有链表相连，它的查询效率比hash就快很多了。且数据库中的索引一般是在磁盘上，数据量大的情况可能无法一次装入内存，B+树的设计可以允许数据分批加载，同时树的高度较低，提高查找效率。

\6. 树你知道哪些？

\7. 前中序遍历，二叉树，二叉搜索树，平衡二叉树，更高级一点红黑树，B tree，B+树

\8. 二叉搜索树极端退化成链表，所以用AVL树，红黑树就是平衡树的一种，复杂的定义和规则最后都是为了保证树的平衡性。

\9. 为什么要保证树的平衡性

 树的查找性能取决于树的高度，让树尽可能平衡，就是为了降低树的高度。

10 .B tree

 是一种多路搜索树，每个节点可以拥有多于两个孩子节点，M路的B树最多能拥有M个孩子节点

11.为什么设计成多路

 为了进一步降低树的高度

\12. 可以设计成无限多路吗

 退化成有序数组了

\13. B树一般用在文件系统的索引

\14. 为什么文件系统的索引用B树而不用红黑树或有序数组

 文件系统和数据库的索引存在硬盘上，并且如果数据量大的话，不一定能一次性加载到内存中。

\15. 如果一棵树无法一次性加载进内存，怎么查找？

 每次加载树的一个节点，然后一步步向下找

如果在内存中，红黑树比B树效率更高，但涉及到硬盘操作，B树更优。

\16. B+树在B树基础上进行改进，数据都在叶子结点，同时叶子结点之间还加了指针形成链表。

\17. B+树为什么这么设计

Select不一定只选一条，很多时候会选多条。这时B树做局部的中序遍历，可能要跨层访问。而B+树由于所有数据都在叶子结点，不用跨层，同时由于有链表结构，只需要找到首尾，通过链表就能把所有数据取出来了。

### 16为什么B+树比B树更适合做数据库索引？

 

  B+树的磁盘读写代价更低。由于B+树内部的结点并没有指向关键字的指针，所以其内部结点相对B树更小，如果把同一内部结点的关键字存放在同一块磁盘中，那么盘块所能容纳的关键字数量也就较多，一次性读入内存需要查找的关键字也越多，相对IO读写次数也就越低。

  B+树的查询效率更加稳定。由于非叶子结点并不是指向文件内容的结点，而只是叶子结点中关键字的索引，所以任何关键字的查找必须走一条从根结点到叶子结点的路，所有关键字查询的路径长度相同，导致每一个数据的查询效率一样。

  B+树在查询时，只需要扫一遍叶子结点就可以了，因为分支结点都为索引，没有存文件内容。而B树分支结点中还存在数据，我们需要找到具体的数据，需要进行一次中序遍历按序扫描，所以B+树更适合在区间查询，因此，B+树更适合用于数据库索引。

 

### 18. 聚簇索引和非聚簇索引

1.首先，我们要认识到聚簇索引和非聚簇索引的划分依据是什么 ？

答案就是 InnoDB 会使用聚簇索索引来保存数据，而非聚簇索引的目的仅仅是加快查询速度

在第一点认知基础上，我们就可以知道

聚簇索引是唯一的，一个 InnoDB 表只有一个聚簇索引，而且一定会有一个聚簇索引，如果不存在，Innodb 存储引擎会自动添加一个

非聚簇所以可以有多个，而且只能由用户自己添加，InnoDB 默认并不会创建任何非聚簇索引。

非聚簇索引中一定包含了聚簇索引的列值，但反过来却不存在。

因此，使用非聚簇索引查询数据一定会用到聚簇索引，但反过来却不存在。

### 19. 聚集索引和非聚集索引

聚集索引和非聚集索引的根本区别是**表记录的排列顺序和与索引的排列顺序是否一致**。

**聚集索引表记录的排列顺序与索引的排列顺序一致**

- 优点是查询速度快，因为一旦具有第一个索引值的纪录被找到，具有连续索引值的记录也一定物理的紧跟其后。
- 缺点是对表进行修改速度较慢，这是为了保持表中的记录的物理顺序与索引的顺序一致，而把记录插入到数据页的相应位置，必须在数据页中进行数据重排， 降低了执行速度。建议使用聚集索引的场合为：
       a. 此列包含有限数目的不同值；
       b. 查询的结果返回一个区间的值；
       c. 查询的结果返回某值相同的大量结果集。

**非聚集索引指定了表中记录的逻辑顺序，但记录的物理顺序和索引的顺序不一致**，聚集索引和非聚集索引都采用了B+树的结构，但非聚集索引的叶子层并不与实际的数据页相重叠，而采用叶子层包含一个指向表中的记录在数据页中的指针的方式。
 非聚集索引比聚集索引层次多，添加记录不会引起数据顺序的重组。
 建议使用非聚集索引的场合为：
 a. 此列包含了大量数目不同的值；
 b. 查询的结束返回的是少量的结果集；
 c. order by 子句中使用了该列。

### 20. 失效的情况：

- 条件中有or

  注：要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引

- 对于多列索引，不是使用的第一部分
- like查询是以%开头
- 列类型是字符串时，没有在条件中将数据使用引号引用起来
- 如果mysql估计使用全表扫描要比使用索引快,则不使用索引

　

此外，查看索引的使用情况

show status like ‘Handler_read%’;
大家可以注意：
handler_read_key:这个值越高越好，越高表示使用索引查询到的次数

handler_read_rnd_next:这个值越高，说明查询低效

### 21[ 与红黑树的比较](https://cyc2018.github.io/CS-Notes/#/notes/MySQL?id=_3-与红黑树的比较)

## sql

### 优化

- 避免select *，只查所需要字段列

- 使用连接（join）来代替子查询

- 拆分大的delete或insert语句

- 使用limit对查询结果的记录进行限定

- 用 exists 代替 in

- 用Where子句替换HAVING 子句 因为HAVING 只会在检索出所有记录之后才对结果集进行过滤

- 不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引尽量避免在where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描；

- 尽量避免在 where 子句中使用 or 来连接条件或使用 !=或<>操作符  ，否则将导致引擎放弃使用索引而进行全表扫描

  

# 简历

熟悉数据库设计，sql 调优 ，mysql   redis  es  hbase

# 书

## sql必知必会总结（42 讲  5.1之前看完     4/42）

https://www.aliyundrive.com/s/gTZxy1hEAp4

### 了解sql

不同的 SQL 的效率是不同的，好的 SQL 执行计划会尽量减少 I/O 操作，因为 I/O 是 DBMS 最容易出现瓶颈的地方，数据库操作中大量时间都在 I/O 上。此外，还需考虑如何降低 CPU 的计算量，在 SQL 中使用 GROUP BY、ORDER  BY 等会消耗大量的 CPU 资源，因此需要从全局出发，不仅需要考虑数据库的 I/O 性能，还需考虑 CPU 计算、内存使用情况等。

**比如 EXIST 查询和 IN 查询在某些情况下可以得到相同的结果，但是具体执行起来，哪个效率更高呢？**

假设把这个模式抽象：

```sql
SELECT * FROM A WHERE cc IN (SELECT cc FROM B)
```

```sql
SELECT * FROM A WHERE EXIST (SELECT cc FROM B WHERE B.cc=A.cc)
```

查询中需要判断表 A 和表 B 的大小。如果表 A 比表 B 大，那么 IN 子查询的效率比 EXIST 子查询效率高。

如果想看 7 天内的新增用户数有多少? 用 NOW() 获取当前时间，转化成天数，与用户注册时间进行对比，小于 7 天即可


```
SELECT COUNT(*) as num FROM new_user WHERE TO_DAYS(NOW())-TO_DAYS(regist_time)<=7
```

MySQL、Oracle 这种的数据库管理系统(DBMS)，都遵循 SQL 语言，


#### DDL

 Data Definition Language，数据定义语言，用来定义数据库对象，包括数据库、数据表和列。通过使用 DDL，我们可以创建，删除和修改数
据库和表结构。

#### DML

 Data Manipulation Language，数据操作语言，操作数据库相关的记录，比如增删改

#### DCL

Data Control Language，数据控制语言，定义访问权限和安全级别

#### DQL

 Data Query Language，数据查询语言，查询记录，SQL 语言的重中之重。实际业务中绝大多数情况下都是查询。

***

SQL 是与 DBMS 交流的语言，创建 DBMS 之前，需要进行设计，对于RDBMS 来说采用的是 ER 图（Entity Relationship Diagram），即实体 - 关系图的方式
进行设计。ER 图评审通过后，再用 SQL 语句或者可视化管理工具（如 Navicat）创建数据表。

ER图有什么用呢？用来描述现实世界的概念模型，模型中有 3 个要素：实体、属性、关系。
实体是管理的对象，属性是标识每个实体的属性，关系是对象之间的关系。比如

大小写不会影响 SQL 的执行，推荐采用写规范，提高效率。

表名、表别名、字段名、字段别名等都小写

SQL 保留字、函数名、绑定变量等都大写。


```
SELECT name, hp_max FROM heros WHERE role_main = '战士'
```

SELECT、FROM、WHERE 这些常用的 SQL 保留字都采用了大写，而 name、hp_max、role_main 这些字段名，表名都采用了小写。此外在数据表的字段名推荐采用下划线命名，比如 role_main 这种。

### DBMS

数据库管理软件，也就是 DBMS。比如 Oracle、MySQL、SQL Server、PostgreSQL、DB2 和MongoDB 等。

1. 主流 DBMS 有哪些，各自有哪些特点；

2. 既然 SQL 是通用标准语言，为什么存在这么多 DBMS；

3. 从这些 DBMS 的发展史中，你有哪些感悟。

  

#### DB、DBS 、 DBMS 区别

-    说到 DBMS，有一些概念需要了解。全称是 DataBase Management System，数据库管理系统，实际上可以对多个数据库进行管理，可以理解为

  ​	 DBMS = 多个数据库（DB） + 管理程序。

-   DB 全称 DataBase，也就是数据库。数据库是存储数据的集合，可以理解为多个数据表。

-   DBS 全称 DataBase System，数据库系统。它是更大的概念，包括了数据库、数据库管理系统以及数据库管理人员 DBA。
   注：虽然有把 Oracle、MySQL 等称之为数据库，但确切讲应该是数据库管理系统，即 DBMS。

#### DBMS分类

![image-20220423224427633](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220423224427633.png)

- 关系型数据库（RDBMS）：是主流，最多的是 Oracle、MySQL 和 SQL Server等，建立在关系模型基础上的数据库，SQL 就是关系型数据库的查询语言。


- 非关系型数据库：相比于 SQL，NoSQL 泛指非关系型数据库，包括了榜单上的键值型数据库、文档型数据库、搜索引擎和列存储等，除此以外还包括图形数据库。
  1.  键值型数据库：通过 Key-Value 键值的方式来存储数据，其中 Key 和 Value 可以是简单对象，也可以是复杂对象。Key 作为唯一的标识符，优点是查找速度快，明显优于关系型数据库。缺点是无法像关系型数据库一样自由使用条件过滤（比如 WHERE），如果不知道去哪找数据，就要遍历所有的键，会消耗大量的计算。键值型数据库典型的使用场景是作为内容缓存。Redis 是最流行的键值型数据库。
  2.   文档型数据库: 用来管理文档，在数据库中文档作为处理信息的基本单位，一个文档相当于 一条记录，MongoDB 是最流行的文档型数据库。
  3.   搜索引擎: 也是数据库检索中的重要应用，常见的全文搜索引擎有 Elasticsearch、Splunk 和 Solr。虽然关系型数据库采用索引提升检索效率，但是针对       全文索引效率却较低。搜索引擎的优势在于采用了全文搜索的技术，核心原理是“倒排索引”。
  4.   列式数据库：相对于行式存储的数据库，Oracle、MySQL、SQL Server 等都采用行式存储（Row-based），而列式数据库是将数据按照列存储到数据库   中，好处是大量降低系统的 I/O，适合于分布式文件系统，不足在于功能相对有限。
  5.   图形数据库，利用了图这种数据结构存储了实体（对象）之间的关系。最典型的例子就是社 交网络中人与人的关系，数据模型主要是以节点和边（关系）来实现，特点在于能高效地解决复杂的关系问题。
  

### 用数据库的方式思考SQL如何执行

####  Oracle 中的 SQL 是如何执行的



![image-20220423230159154](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220423230159154.png)



执行过程如上图，可以看出，SQL 在 Oracle 中经历了以下几个步骤。

- 语法检查：检查 SQL 拼写是否正确，如果不正确，Oracle 会报语法错误。

- 语义检查：检查 SQL 中的访问对象是否存在。比如 SELECT 语句列名写错了，系统就会提示错误。语法检查和语义检查的作用是保证 SQL 语句没有错
  误。

- 权限检查：看用户是否具备访问该数据的权限

- 共享池检查：共享池（Shared Pool）是一块内存池，最主要的作用是缓存 SQL 语句和该语句的执行计划。Oracle 通过检查共享池是否存在 SQL 语句的执行计划，来判断进行软解析还是硬解析。那软解析和硬解析又该怎么理解呢？在共享池中，Oracle 首先对 SQL 语句进行 Hash 运算，然后根据 Hash 值在库缓存（Library Cache）中查找，如果存在 SQL 语句的执行计划，就直接拿来执行，直接进入“执行器”的环节，这就是软解析。如果没有找到 SQL 语句和执行计划，Oracle 就需要创建解析树进行解析，生成执行计划，进入“优化器”这个步骤，这就是硬解析。

- 优化器：优化器中就是要进行硬解析，也就是决定怎么做，比如创建解析树，生成执行计划。

- 执行器：当有了解析树和执行计划之后，就知道了 SQL该怎么被执行，这样就可以在执行器中执行语句了

  共享池是 Oracle 中的术语，包括了库缓存，数据字典缓冲区等。我们上面已经讲到了库缓存区，它主要缓存 SQL 语句和执行计划。而数据字典缓冲区存储的是 Oracle 中的对象定义，比如表、视图、索引等对象。当对 SQL 语句进行解析的时候，如果需要相关的数据，会从数据字典缓冲区中提取。库缓存这一个步骤，决定了 SQL 语句是否需要进行硬解析。为了提升 SQL 的执行效率，我们应该尽量避免硬解析，因为在 SQL 的执行过程中，创建解析树，生成执行计划是很消耗资源的。你可能会问，如何避免硬解析，尽量使用软解析呢？在Oracle 中，绑定变量是一大特色。绑定变量就是在SQL 语句中使用变量，通过不同的变量取值来改变 SQL 的执行结果。这样做的好处是能提升软解析的可能性，不足之处在于可能会导致生成的执行计划不够优化，因此是否需要绑定变量视情况而定。

  举个例子

  ```
   SQL> select * from player where player_id = 10001;
  ```


  可以使用绑定变量，如：

  ```
   SQL> select * from player where player_id = :player_id;
  ```

  这两个查询语句的效率在 Oracle 中是完全不同的。如果在查询 player_id = 10001 之后，还会查询 10002、10003 之类的数据，那么每一次查询都会创建一个新的查询解析。而第二种方式使用了绑定变量，那么在第一次查询之后，在共享池中就会存在这类查询的执行计划，也就是软解析。因此可以通过使用绑定变量来减少硬解析，减少Oracle 的解析工作量。但是这种方式也有缺点，使用动态SQL 的方式，因为参数不同，会导致 SQL 的执行效率不同，同时 SQL 优化也会比较困难。

  

  #### MySQL 中的 SQL 是如何执行的

  ![image-20220423231417432](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220423231417432.png)

   整体的 MySQL 流程如上图， MySQL 是典型的 C/S 架构，即 Client/Server 架构，服务器端程序使用的 mysqld。 MySQL 由三层组成：

  1. 连接层：客户端和服务器端建立连接，客户端发送 SQL至服务器端
  2. SQL 层：对 SQL 语句进行查询处理
  3. 存储引擎层：与数据库文件打交道，负责数据的存储和读取

  其中 SQL 层与数据库文件的存储方式无关，如下图

  1. ![image-20220423231323513](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220423231323513.png)
     
  1. 缓存查询：Server 如果在查询缓存中发现了这条 SQL 语句，就会直接将结果返回给客户端；如果没有，就进入到
     解析器阶段。需要说明的是，因为查询缓存往往效率不高，所以在 MySQL8.0 之后就抛弃了这个功能。

  2. 解析器：对 SQL 语句进行语法分析、语义分析

  3. 优化器：确定 SQL 语句的执行路径，比如是根据全表检索，还是根据索引来检索等。

  4. 执行器：在执行之前需要判断该用户是否具备权限，如果具备权限就执行 SQL 查询并返回结果。在 MySQL8.0 以
     下的版本，如果设置了查询缓存，这时会将查询结果进行缓存。

     你能看到 SQL 语句在 MySQL 中的流程是：SQL 语句→缓存查询→解析器→优化器→执行器。在一部分中，MySQL和 Oracle 执行 SQL 的原理是一样的。
     与 Oracle 不同的是，MySQL 的存储引擎采用插件的形式，每个存储引擎都面向一种特定的数据库应用环境。同时开源的 MySQL 还允许开发人员设置自己的存储引擎，下面是一些常见的存储引擎：

     - InnoDB ：它是 MySQL 5.5 版本之后默认的存储引擎，最大的特点是支持事务、行级锁定、外键约束等。

     - MyISAM ： MySQL 5.5 版本之前默认的存储引擎，不支持事务，也不支持外键，最大的特点是速度快，占用资源少。

     - Memory :使用系统内存作为存储介质，以便得到更快的响应速度。不过如果 mysqld 进程崩溃，则会导致所有数据丢失，因此只有数据是临时情况下才使用 

     - NDB:也叫做 NDB Cluster 存储引擎，主要用于 MySQL Cluster 分布式集群环境，类似于 Oracle 的RAC 集群

     - Archive:：有很好的压缩机制，用于文件归档，在请求写入时会进行压缩，所以也经常用来做仓库。

       需要注意的是，数据库的设计在于表的设计，而在 MySQL中每个表的设计都可以采用不同的存储引擎，可以根据实际的数据处理需要来选择存储引擎，这也是 MySQL 的强大之处。

#### 数据库管理系统也是一种软件

刚才了解了 SQL 语句在 Oracle 和 MySQL 中的执行流程，实际上完整的 Oracle 和 MySQL 结构图要复杂得多：如果只是简单地把 MySQL 和 Oracle 看成数据库管理系统软件，从外部看难免会觉得“晦涩难懂”，毕竟组织结构太多了。我们在学习的时候，还需要具备抽象的能力，抓取最核心的部分：SQL 的执行原理。因为不同的 DBMS 的 SQL 的执行原理是相通的，只是在不同的软件中，各有各的实现路径。既然一条 SQL 会经历不同的模块，那我们就来看下，在不同的模块中，SQL 执行所使用的资源（时间）是怎样的。下面我来教你如何在 MySQL 中对一条 SQL 的执行时间进行分析。



  首先我们需要看下 profiling 是否开启，开启可以让 MySQL 收集在 SQL 执行时所使用的资源情况，命令如下：

```
mysql> select @@profiling;    //0 代表关闭

mysql> set profiling=1;  //打开
```

执行SQL 

```
mysql> select * from wucai.heros;
```

   查看当前会话所有 profiles：

```
mysql> show profile;
```

![image-20220424074747204](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220424074747204.png)

  

   发现刚才执行了两次查询，Query ID 分别为 1 和 2。如果想要获取上一次查询的执行时间，可以使用：

![image-20220424074908386](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220424074908386.png)



也可查询指定的 Query ID，比如：

```
mysql> show profile for query 2;
```

查询 SQL 的执行时间结果和上面是一样的。

在 8.0 版本之后，MySQL 不再支持缓存的查询，原因上文已说过。一旦数据表有更新，缓存都将清空，因此只有数据表是静态的时候，或者数据表很少发生变化时，缓存查询才有价值，否则如果数据表经常更新，增加 SQL 查询时间。

```
mysql> select version()  //查看版本情况
```



总结：使用 SQL 的时候，往往只见树木，不见森林，不会注意到在各种数据库软件中如何执行，今天我们从全貌的角度来理解这个问题。能看到不同 RDBMS 之间有相同的地方，也有不同的地方。 相同的地方在于 Oracle 和 MySQL 都是通过解析器→优化器→执行器这样的流程来执行 SQL 。
但 Oracle 和 MySQL 在进行 SQL 的查询上面有软件实现层面的差异。Oracle 提出了共享池的概念，通过共享池来判断是进行软解析还是硬解析。而在 MySQL 中，8.0 以后的版本不再支持查询缓存，而是直接执行解析器→优化器→执行器的流程，这一点从 MySQL 中的 show profile 里也能看到。同时 MySQL 的一大特色就是提供了各种存储引擎以供选择，不同的存储引擎有各自的使用场景，可以针对每张表选择适合的存储引擎。

### 使用DDL创建数据库&数据表时需要注意什么？

  DDL 是 DBMS 的核心组件，也是 SQL 的重要组成部分，DDL 的正确性和稳定性是整个 SQL 运行的重要基础。

#### 基础语法及设计工具

全称是 Data Definition Language，即数据定义语言。定义了数据库的结构和数据表的结构。在 DDL 中常用功能是增删改，分别对应的命令是
CREATE、DROP 和 ALTER。需要注意的是，在执行 DDL的时候，不需要 COMMIT，就可以完成执行任务。

1.对数据库进行定义

```
CREATE DATABASE nba; // 创建一个名为 nba 的数据库
DROP DATABASE nba; // 删除一个名为 nba 的数据库
```

2.对数据表进行定义

```
CREATE TABLE table_name  //创建表
```

#### 创建表结构

比如想创建一个球员表，表名为 player，里面有两个字段，一个是 player_id，它是 int 类型，另一个player_name 字段是varchar(255)类型。这两个字段都
不为空，且 player_id 是递增的。

```
CREATE TABLE player (
 player_id int(11) NOT NULL AUTO_INCREMENT,
 player_name varchar(255) NOT NULL
);
```

注：语句最后以分号（;）作为结束符，最后一个字段的定义结束后没有逗号。数据类型中 int(11) 代表整数类型，显示长度为 11 位，括号中的参数 11 代表的是最大有效显示长度，与类型包含的数值范围大小无关。varchar(255)代表的是最大长度为 255 的可变字符串类型。NOT NULL表明整个字段不能是空值，是一种数据约束。AUTO_INCREMENT代表主键自动增长。

实际上，通常很少自己写 DDL 语句，可以使用一些可视化工具来创建和操作数据库和数据表。在这里我推荐使用Navicat，它是一个数据库管理和设计工具，跨平台，支持很多种数据库管理软件，比如 MySQL、Oracle、MariaDB等。基本上专栏讲到的数据库软件都可以使用 Navicat 来管理。
假如还是针对 player 这张表，我们想设计以下的字段：

![image-20220424080742918](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220424080742918.png)

其中 player_id 是数据表 player 的主键，且自动增长，也就是 player_id 会从 1 开始，然后每次加 1。player_id、team_id、player_name 这三个字段均不为空，height 字段可以为空。
按照上面的设计需求，我们可以使用 Navicat 软件进行设计，如下所示：

![image-20220424080808473](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220424080808473.png)

们还可以对 player_name 字段进行索引，索引类型为Unique。

![image-20220424080836748](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220424080836748.png)

可以把这张表导出来，看看对应的 SQL 语句的。右键选中表，选择“转储 SQL 文件”→“仅结构”，可以看到导出的 SQL 了，代码如下：

```
DROP TABLE IF EXISTS `player`;
CREATE TABLE `player` (
 `player_id` int(11) NOT NULL AUTO_INCREMENT,
 `team_id` int(11) NOT NULL,
 `player_name` varchar(255) CHARACTER SET utf8 COLLATE
 `height` float(3, 2) NULL DEFAULT 0.00,
 PRIMARY KEY (`player_id`) USING BTREE,
 UNIQUE INDEX `player_name`(`player_name`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_g
```



首先先删除player 表（如果数据库中存在该表的话），然后再创建player 表，里面的数据表和字段都使用了反引号，为了避免名称与 MySQL 保留字段相同，对数据表和字段名称都加上了反引号。其中 player_name 字段的字符集是 utf8，排序规则是utf8_general_ci，代表对大小写不敏感，如果设置为utf8_bin，代表对大小写敏感，还有许多其他排序规则这里不进行介绍。

因为 player_id 设置为了主键，因此在 DDL 中使用PRIMARY KEY进行规定，同时索引方法采用 BTREE。


因为对 player_name 字段进行索引，在设置字段索引时，可以设置为UNIQUE INDEX（唯一索引），也可以设置为其他索引，比如NORMAL INDEX（普通索引），这里我们采用UNIQUE INDEX。**唯一索引和普通索引的区别在于它对字段进行了唯一性的约束**。在索引方式上，你可以选择BTREE或者HASH，这里采用了BTREE方法进行索引。

整个数据表的存储规则采用 InnoDB。之前我们简单介绍过InnoDB，它是 MySQL5.5 版本之后默认的存储引擎。同时，我们将字符集设置为 utf8，排序规则为
utf8_general_ci，行格式为Dynamic，就可以定义数据表的最后约定了：


####  修改表结构
```
 ALTER TABLE player ADD (age int(11));   //添加 age 字段，类型为int(11)
 
 ALTER TABLE player RENAME COLUMN age to player_age //修改字段名，将 age 字段改成player_age
 
 ALTER TABLE player MODIFY (player_age float(3,1));  //修改字段数据类型，将player_age的数据类型设置为float(3,1)
 
 ALTER TABLE player DROP COLUMN player_age;  //删除字段, 删除Player_age字段

```


#### 数据表的常见约束

当我们创建数据表的时候，还会对字段进行约束，约束的目
的在于保证 RDBMS 里面数据的准确性和一致性。下面，我
们来看下常见的约束有哪些。
首先是主键约束。
主键起的作用是唯一标识一条记录，不能重复，不能为空，
即 UNIQUE+NOT NULL。一个数据表的主键只能有一个。
主键可以是一个字段，也可以由多个字段复合组成。在上面
的例子中，我们就把 player_id 设置为了主键。
其次还有外键约束。
1 
 复制代码
1 
 复制代码
外键确保了表与表之间引用的完整性。一个表中的外键对应
另一张表的主键。外键可以是重复的，也可以为空。比如
player_id 在 player 表中是主键，如果你想设置一个球员比
分表即 player_score，就可以在 player_score 中设置
player_id 为外键，关联到 player 表中。
除了对键进行约束外，还有字段约束。
唯一性约束。
唯一性约束表明了字段在表中的数值是唯一的，即使我们已
经有了主键，还可以对其他字段进行唯一性约束。比如我们
在 player 表中给 player_name 设置唯一性约束，就表明任
何两个球员的姓名不能相同。需要注意的是，唯一性约束和
普通索引（NORMAL INDEX）之间是有区别的。唯一性约
束相当于创建了一个约束和普通索引，目的是保证字段的正
确性，而普通索引只是提升数据检索的速度，并不对字段的
唯一性进行约束。
NOT NULL 约束。对字段定义了 NOT NULL，即表明该字
段不应为空，必须有取值。
DEFAULT，表明了字段的默认值。如果在插入数据的时
候，这个字段没有取值，就设置为默认值。比如我们将身高
height 字段的取值默认设置为 0.00，即DEFAULT 0.00。
CHECK 约束，用来检查特定字段取值范围的有效性，
CHECK 约束的结果不能为 FALSE，比如我们可以对身高
height 的数值进行 CHECK 约束，必须≥0，且＜3，即
CHECK(height>=0 AND height<3)。
设计数据表的原则
我们在设计数据表的时候，经常会考虑到各种问题，比如：
用户都需要什么数据？需要在数据表中保存哪些数据？哪些
数据是经常访问的数据？如何提升检索效率？
如何保证数据表中数据的正确性，当插入、删除、更新的时
候该进行怎样的约束检查？
如何降低数据表的数据冗余度，保证数据表不会因为用户量
的增长而迅速扩张？
如何让负责数据库维护的人员更方便地使用数据库？
除此以外，我们使用数据库的应用场景也各不相同，可以说
针对不同的情况，设计出来的数据表可能千差万别。那么有
没有一种设计原则可以让我们来借鉴呢？这里我整理了一
个“三少一多”原则：
1.数据表的个数越少越好
RDBMS 的核心在于对实体和联系的定义，也就是 E-R 图
（Entity Relationship Diagram），数据表越少，证明实
体和联系设计得越简洁，既方便理解又方便操作。
2.数据表中的字段个数越少越好
字段个数越多，数据冗余的可能性越大。设置字段个数少的
前提是各个字段相互独立，而不是某个字段的取值可以由其
他字段计算出来。当然字段个数少是相对的，我们通常会在
数据冗余和检索效率中进行平衡。
3.数据表中联合主键的字段个数越少越好
设置主键是为了确定唯一性，当一个字段无法确定唯一性的
时候，就需要采用联合主键的方式（也就是用多个字段来定
义一个主键）。联合主键中的字段越多，占用的索引空间越
大，不仅会加大理解难度，还会增加运行时间和索引空间，
因此联合主键的字段个数越少越好。
4.使用主键和外键越多越好
数据库的设计实际上就是定义各种表，以及各种字段之间的
关系。这些关系越多，证明这些实体之间的冗余度越低，利
用度越高。这样做的好处在于不仅保证了数据表之间的独立
性，还能提升相互之间的关联使用率。
你应该能看出来“三少一多”原则的核心就是简单可复用。
简单指的是用更少的表、更少的字段、更少的联合主键字段
来完成数据表的设计。可复用则是通过主键、外键的使用来
增强数据表之间的复用率。因为一个主键可以理解是一张表
的代表。键设计得越多，证明它们之间的利用率越高。
总结
今天我们学习了 DDL 的基础语法，比如如何对数据库和数
据库表进行定义，也了解了使用 Navicat 可视化管理工具来
辅助我们完成数据表的设计，省去了手写 SQL 的工作量。
在创建数据表的时候，除了对字段名及数据类型进行定义以
外，我们考虑最多的就是关于字段的约束，我介绍了 7 种常
见的约束，它们都是数据表设计中会用到的约束：主键、外
键、唯一性、NOT NULL、DEFAULT、CHECK 约束等。
当然，了解了如何操作创建数据表之后，你还需要动脑思
考，怎样才能设计出一个好的数据表？设计的原则都有哪
些？针对这个，我整理出了“三少一多”原则，在实际使用
过程中，你需要灵活掌握，因为这个原则并不是绝对的，有
时候我们需要牺牲数据的冗余度来换取数据处理的效率。
我们在创建数据表的时候，会对数据表设置主键、外键和索
引。你能说下这三者的作用和区别吗？
欢迎你在评论区写下你的答案，我会和你一起交流，也欢迎
把这篇文章分享给你的朋友或者同事。