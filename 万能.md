[TOC]

# 开发

## 遇到的bug



3.连接超时  可能host没配

4.Error:java: Compilation failed: internal java compiler error

 jdk版本和jar包不兼容 检查是否jdk版本过低或jar包版本过低

6.疑似乱码错误：清缓存 或者开无痕模式

![img](D:/yunan10/Documents/JD/office_dongdong/yunan10/Temp/JdOnline20210317151207.png) 

6.Handler dispatch failed; nested exception is java.lang.NoClassDefFoundError: org/apache/http/impl/client/HttpClients

缺少 jar 依赖包 ： httpclient

<dependency>
    <groupId>org.apache.httpcomponents</groupId>
    <artifactId>httpclient</artifactId>
    <version>4.5.5</version>
</dependency>

### mybaits

1.mybatis org.apache.ibatis.binding.BindingException异常

.xml文件要和接口的路径一致

2.[IDEA右键新建时没有Java Class选项](https://www.cnblogs.com/zimo-jing/p/9628784.html)

![image-20210421150651842](C:\Users\yunan10\AppData\Roaming\Typora\typora-user-images\image-20210421150651842.png)

3.Mybatis 查询返回List<String>集合

https://blog.csdn.net/sotong006/article/details/81697814

4.从数据库查值 哪些需要判空

1.如果返回值类型是list，数据库查不到数据时会返回size=0,即相当于List users = new ArrayList();users的size=0。

2.返回实体,数据库查不到 返回null 注意判空

3.返回值类型是String，数据库查不到数据时会返回空字符串，即相等于String str = “”;



## 编程习惯

2.hashmap  arraylist 初始化指定初始容量   防止扩容影响效率

3.接口入参尽量用类，这样即使以后修改参数，对外暴露仍然是那个类

# 软件

## idea

### 问题



#### 异常捕捉不到

考虑是不是抛出error，但是代码却捕捉的Exception

#### 已经依赖的类引入不了

POM文件引入了，重新刷新maven不好用，重新拉项目不管用。 清下idea缓存

https://blog.csdn.net/lilinaixuexi/article/details/78612083

###  集成插件

#### 问题

#### 数据库

3. 注释模板

   类模版：
   
   ![image-20220111180418725](/Users/yunan10/Library/Application Support/typora-user-images/image-20220111180418725.png)

/**

/**
*
* @Description: 
* @Author: yunan10
* @Date: ${DATE} 
**/

方法模版：

1.新建组

![image-20220111181311599](/Users/yunan10/Library/Application Support/typora-user-images/image-20220111181311599.png)

2.组下新建模版

![image-20220111181511186](/Users/yunan10/Library/Application Support/typora-user-images/image-20220111181511186.png)

3.

![image-20220113145252292](/Users/yunan10/Library/Application Support/typora-user-images/image-20220113145252292.png)



模版命名yn, 注释模版如下

```
/*
 * @Description  $end$
 * @Param $param$
 * @return $return$
 **/
```



4.选择应用场景

![image-20220113145401858](/Users/yunan10/Library/Application Support/typora-user-images/image-20220113145401858.png)



![image-20220113145413034](/Users/yunan10/Library/Application Support/typora-user-images/image-20220113145413034.png)





5.输入模版标识就行

![image-20220113145505805](/Users/yunan10/Library/Application Support/typora-user-images/image-20220113145505805.png)

#### lombok

1.you aren't using a compiler supported by lombok so lombok will not work and has been disabled

加  -Djps.track.ap.dependencies=false

### 搭建项目

#### Spring mvc

1.创建Maven项目，选择Create form archetype，使用webapp模板

![环境搭建](https://img-blog.csdnimg.cn/20191130233540140.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE2ODE5MA==,size_16,color_FFFFFF,t_70#pic_center)

2.如果什么都不修改，除了取名以外一直点下一步的话，完成以后开始等待创建项目会很慢（和网络无关，挂代理也会很慢），好不容易等了几分钟，最后的结果如下图，可以看到写的是No archetype found in remote catalog. Defaulting to internal catalog。就是在远程目录中找不到原型，默认为内部目录，既然远程目录没有，那可不可以通过配置直接选择使用内部目录，没错，可以。

![结果](https://img-blog.csdnimg.cn/20191201000037550.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE2ODE5MA==,size_16,color_FFFFFF,t_70#pic_center)

所以创建项目时不要急着点下一步，在写好项目名字的下一步里点击右上角的“+”添加一项配置，archetypeCatalog，值为internal。如下图，可以直接使用内部目录，避免等待。

![添加配置](https://img-blog.csdnimg.cn/20191201001036927.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE2ODE5MA==,size_16,color_FFFFFF,t_70#pic_center)

这次点击finish后只等了几秒项目就创建完毕了。

2。补全目录

在main下创建java和resources目录，但是普通的目录并不能创建类，要右键→make diry as source root，同时把resources也设置成resources root。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191201002015924.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE2ODE5MA==,size_16,color_FFFFFF,t_70#pic_center)

3.导入依赖

替换pom.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>org.example</groupId>
  <artifactId>springlearn</artifactId>
  <version>1.0-SNAPSHOT</version>
  <packaging>war</packaging>

  <name>springlearn Maven Webapp</name>
  <!-- FIXME change it to the project's website -->
  <url>http://www.example.com</url>

  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <maven.compiler.source>1.7</maven.compiler.source>
    <maven.compiler.target>1.7</maven.compiler.target>
    <java.version>8</java.version>
    <spring.version>5.2.0.RELEASE</spring.version>
  </properties>

  <dependencies>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>4.11</version>
      <scope>test</scope>
    </dependency>

    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-context</artifactId>
      <version>${spring.version}</version>
    </dependency>

    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-webmvc</artifactId>
      <version>${spring.version}</version>
    </dependency>

    <dependency>
      <groupId>javax.servlet</groupId>
      <artifactId>servlet-api</artifactId>
      <version>2.5</version>
      <scope>provided</scope>
    </dependency>

    <dependency>
      <groupId>javax.servlet.jsp</groupId>
      <artifactId>jsp-api</artifactId>
      <version>2.2.1-b03</version>
      <scope>provided</scope>
    </dependency>


  </dependencies>

  <build>
    <finalName>springlearn</finalName>
    <pluginManagement><!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) -->
      <plugins>
        <plugin>
          <artifactId>maven-clean-plugin</artifactId>
          <version>3.1.0</version>
        </plugin>
        <!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging -->
        <plugin>
          <artifactId>maven-resources-plugin</artifactId>
          <version>3.0.2</version>
        </plugin>
        <plugin>
          <artifactId>maven-compiler-plugin</artifactId>
          <version>3.8.0</version>
        </plugin>
        <plugin>
          <artifactId>maven-surefire-plugin</artifactId>
          <version>2.22.1</version>
        </plugin>
        <plugin>
          <artifactId>maven-war-plugin</artifactId>
          <version>3.2.2</version>
        </plugin>
        <plugin>
          <artifactId>maven-install-plugin</artifactId>
          <version>2.5.2</version>
        </plugin>
        <plugin>
          <artifactId>maven-deploy-plugin</artifactId>
          <version>2.8.2</version>
        </plugin>
      </plugins>
    </pluginManagement>
  </build>
</project>

```

4.配置前端控制器

在webapp/WEB-INF/web.xml中配置

```xml
  <servlet>
    <servlet-name>dispatcherServlet</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
  </servlet>
  <servlet-mapping>
    <servlet-name>dispatcherServlet</servlet-name>
    <url-pattern>/</url-pattern>
  </servlet-mapping>
```

5.创建springmvc 配置文件

在resources中新建spring配置文件，取名为springmvc

![新建spring配置文件](https://img-blog.csdnimg.cn/20191201105128696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE2ODE5MA==,size_16,color_FFFFFF,t_70#pic_center)

问题：Java resources里面创建xml 没有spring config

```xml
 <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context</artifactId>
        <version>5.0.5.RELEASE</version>
  </dependency
```
6.配置服务器

在运行按钮旁边添加配置，使用Tomcat Server，在Deployment中添加Artifact

![配置服务器](https://img-blog.csdnimg.cn/20191201105521277.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE2ODE5MA==,size_16,color_FFFFFF,t_70)

原本自带的index.jsp里面没有jsp的头，输入中文会乱码，删掉index.jsp，然后重新创建一个，会自动生成头。然后添加一个超链接。或者直接复制下面的：

```jsp
<%--
  Created by IntelliJ IDEA.
  User: 
  Date: 2019/12/1
  Time: 11:07
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    <h1>入门程序</h1>
    <a href="hello">入门程序</a>
</body>
</html>

```

2.创建控制器类

创建HelloController类，使用这个类时需要创建对象，可以交给spring的容器来处理，那么就需要使用注解

```java
package com.yn;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

/**
 * @description:
 * @author: yunan10
 * @Date: 2021/3/22
 */

@Controller
public class HelloController {

    @RequestMapping(path = "/hello")
    public String hello(){
        System.out.println("s");
        return "ss";
    }
}

```

3.修改spring配置文件并载入配置文件

既然要用到自动注入，需要在配置文件中告诉它要扫描的包，同时要添加一些名称空间

```xml
<!-- 开启注解扫描 -->
<context:component-scan base-package="com.yn"/>
```

到现在，虽然配置文件配置好了，但是并没有被使用，需要在web.xml中进行初始化

  ```xml
<servlet>
    <servlet-name>dispatcherServlet</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <!-- 初始化配置文件 -->
    <init-param>
      <param-name>contextConfigLocation</param-name>
      <param-value>classpath:springmvc.xml</param-value>
    </init-param>
    <load-on-startup>1</load-on-startup>
  </servlet>
  <servlet-mapping>
    <servlet-name>dispatcherServlet</servlet-name>
    <url-pattern>/</url-pattern>
  </servlet-mapping>
  ```

4.创建跳转页面
将HelloController中的方法返回值设置为"success"，会看到提示：No viewer resolvers found。需要创建一个success.jsp来给前端显示。在WEB-INF文件夹下新建一个目录pages，里面创建一个success.jsp文件，里面body随便写一些内容。
5.配置视图解析器

为了让方法能找到这个jsp，我们需要配置一个视图解析器，在springmvc.xml中添加一个bean，顺便一提，我们后面的开发肯定会用到注解，这里把SpringMVC注解支持也打开。

```xml
<!-- 视图解析器对象 -->
<bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver">
   <!-- 前缀（目录） -->
   <property name="prefix" value="/WEB-INF/pages/"/>
   <!-- 后缀 -->
   <property name="suffix" value=".jsp"/>
</bean>

<!-- 开启SpringMVC框架注解的支持 -->
<mvc:annotation-driven/>
```




# 编译部署

1.idea 打war包

https://blog.csdn.net/zhang135687/article/details/84101524

2.idea 添加tomcat

run ->  Edit configuration -> +号

## Tomcat

### 问题

1. Jdk1.8 和 tomacat7.0 有问题,和 tomacat8.0配套.（但是maven自带的tomcat7插件现在未出现问题？）

2. Idea启动Tomcat控制台中文乱码

   Idea:HELP->Edit Custom VM OPtions中加 -Dfile.encoding=utf-8 然后重启IDEA

   run->Edit Configurations->VM  OPtions中加 -Dfile.encoding=utf-8

### 装配bean的方式

#### 1.自动化装配

###### 1.1 创建可被发现的bean

```css
@Component表明该类会作为组件类,并告知Spring要为这个类创建bean
```

启用组件扫描

注:@configuration:表明是一个配置类

```java
@ComponentScan
public class CDPlayerConfig{
}   
 <context: componnet-scan base-package="soundsystem">
```

***

@ComponentScan 不生效的原因： 原因是因为这个配置类没有先在Spring中注册

```java
@Configuration
@ComponentScan(value = "com.yn.controller")
public class CDPlayerConfig {
}
```

```xml
<bean id="cdPlayerConfig" class="com.yn.controller.CDPlayerConfig">
</bean>
```

***

##### 1.2为组件扫描的bean命名

如果没有设置ID,默认id为类名的第一个字母小写.

```java
@Component("lonelyHeartsClub") //设置期望的ID
public class SgtPeppers implements CompactDisc{
}
```

另外还一种为bean命名的方式,使用Java依赖注入规范中所提供的@Named注解来为bean设置ID

```java
@Named("lonelyHeartsClub")
public class SgtPeppers implements CompactDisc{
}
```

##### 1.3设置组件扫描的基础包

```kotlin
//直接在value属性中指明包的名称
@Configuration
@ComponentScan("soundsystem")
public class CDPlayerConfig{}

//通过basePackages属性配置
@Configuration
@ComponentScan(basePackages="soundsystem")
public class CDPlayerConfig{}

//设置多个基础包,用数组表示
@Configuration
@ComponentScan(basePackages={"soundsystem","video"})
public class CDPlayerConfig{}

//基础包以String类型表示是不安全的,如果重构代码的话,指定的基础包可能会出现错误,用指定为包中所包含的类或接口的方法
@Configuration
@ComponentScan(basePackageClasses={CDPlayer.class,DVDPlayer.class})
public class CDPlayerConfig{}
```

但是,很多对象会依赖其他对象才能完成任务,这样的话,我们需要有一种方法能够将组件扫描得到的bean和它们的依赖装配在一起,那就需要自动装配.

##### 1.4通过bean添加注解实现自动装配

@Autowired

```java
@Component
public class CDPlayer implements MediaPlayer{
  private CompactDisc cd;

  @Autowired//这表明当Spring创建CDPlayer bean的时候,会通过这个构造器来进行实例化并且会传入一个可设置给CompactDisc类型的bean.
  public CDPlayer(CompactDisc cd){//构造器
    this.cd = cd;
  }

  public void paly(){
    cd.paly();
  }
}
```

@Autowired注解不仅能够用在构造器上,还能用在属性的Setter方法上.比如说,如果CDPlayer有一个setCompactDisc()方法,那么可以采用如下的注解形式进行自动装配:

```java
@Autowired
public void setCompactDisc(CompactDisc cd){
  this.cd = cd;
}
```

但是如果没有匹配的bean,那么在应用上下文创建的时候,Spring会抛出一个异常,为了避免异常的出现,你可以将@Autowired的requied属性设置为false

```java
@Autowired(required=false)
public void setCompactDisc(CompactDisc cd){
  this.cd = cd;
}
```

但是
 一,把required属性设置为false时,你需要谨慎对待,如果代码中没有进行null检查的话,这个处于未装配的属性有可能会出现空指针异常.
 二,如果有多个bean都能满足依赖关系的话,Spring将会抛出一个异常,表明没有明确指定要选择哪个bean进行自动装配,这个以后再讨论.

```dart
@Autowired可以换成@Inject,@Inject注解来源于Java依赖注入规范,该规范同时还为我们定义了@Named注解.
尽管@Inject和@Autowierd有细微的差别,但大多数场景下,它们都可以互换.
```

### 二  通过Java代码装配bean

有些情况下,比如说,要将第三方库的组件装配到你的应用中,就不能在它的类上添加@Component和@Autowired注解的,因此,就不能使用自动化装配的方案了.
 在这种情况下,就需要采用显示装配的方式.在进行显示配置有Java和XML两种方案.

##### 2.1创建配置类(JavaConfig类)

```java
@Configuration
public class CDPlayerConfig{}
//创建JavaConfig类的关键在于为其添加@Configruation注解,表明这是一个配置类
```

##### 2.2声明简单的bean

```java
@Bean
public CompactDisc sgtPeppers(){
  return new SgtPeppers();
}
//@Bean注解会告诉Spring这个方法将会返回一个对象,该对象要注册为Spring应用上下文的bean,默认情况下,
bean的ID于带有@Bean注解的方法名一样,也可以重命名

@Bean(name="lonelyHeartsClubBand")
public CompactDisc sgtPeppers(){
  return new SgtPeppers();
}
```

##### 2.3借助JavaConfig实现注入

声明CompactDisc bean是非常简单,它自身没有其他依赖,但现在,我们需要声明CDPlayer bean,它依赖于CompactDisc,在JavaConfig中,如何将他们装配在一起呢?

在JavaConfig中装配bean的最简单方式就是 引用创建bean的方法.



```java
@Bean
public CDPlayer cdPlayer(){
  return new CDPlayer(sgtPeppers());
}
//因为sgtPeppers()方法上添加了@Bean注解,Spring将会拦截所有对它的调用,
//并确保直接返回该方法创建的bean,而不是每次都对其进行实际的调用.
```

默认情况下,Spring中的bean都是单例,所以,Spring会拦截对sgtPeppers()的调用并确保返回的是Spring所创建的bean,也就是Spring本身在调用sgtPeppers()时所创建的CompactDisc bean.

如果调用方法来引用bean的方式有点困惑,也可以这么理解



```java
@Bean
public CDPlayer cdPlayer(CompactDisc compactDisc){
  return new CDPlayer(compactDisc);
}
//在这里,cdPlayer()方法请求一个CompactDisc作为参数,当Springs调用cdPlayer()创建CDPlayer bean的时候,
//它会自动装配一个CompactDisc到配置方法之中,然后方法体按照合适的方法来使用它.
```

也可以通过Setter方法注入CompactDisc



```java
@Bean
public CDPlayer cdPlayer(CompactDisc compactDisc){
  CDPlayer cdPlayer = new CDPlayer(compactDisc);
  cdPlayer.setCompactDisc(compactDisc);
  return cdPlayer;
}
```

### 三 通过XML装配bean

##### 3.1创建XML配置规范



```jsx
<?xml version="1.0" encoding="UTF-8">
<beans xmlns="http://........"
             xmlns:xsi="http://.....''>
  <!--  configuration details go here -->
</beans>
//借助Spring Tool Suite 创建XML配置文件
```

##### 3.2声明一个简单的<bean>



```csharp
<bean class="soundsystem.SgtPeppers" />
//这里声明一个很简单的bean,因为没有明确给定ID,所以这个bean将会根据全限定类名来进行命名,
//这里的bean的ID将会是"soundsystem.SgtPeppers#0".其中,"#0"是一个计数的形式,来区分相同类型的bean.

//更好的方法是借助id属性
<bean id="compactDisc" class="soundsystem.SgtPeppers" />

//XML装配bean的缺点
//1.当Spring发现这个<bean>元素时,它将会调用SgtPeppers的默认构造器来创建bean.在XML配置中,bean的创建显得更加被动
//2.不如JavaConfig强大,在JavaConfig配置中,可以通过任何想象到的方法来创建bean实例(构造器,set方法等)
//3.在简单的<bean>声明中,将bean的类型以字符串的形式设置在了class属性中,不能保证设置给class属性的值是真正的类
//4.重命名了类,也会引起麻烦
```

##### 3.3借助构造器注入初始化bean

有两种基本的配置方案可选择
 1.<constructor-arg>元素
 2.使用Spring3.0所引入的c-命名空间

##### (1)构造器注入--bean引用



```jsx
<bean id="cdPlayer" class="soundsystem.CDPlayer">
  <constructor-arg ref="compactDisc">
</bean>
//当Spring遇到<bean>这个元素时,它会创建一个CDPlayer实例.<constructor-arg>元素会告知Spring要将
//一个ID为compactDisc的bean引用传递到CDPlayer的构造器中.
```

作为替代方案,也可以使用Spring的c-命名空间
 要在XML的顶部声明其模式



```php
<?xml version="1.0" encoding="UTF-8">
<beans xmlns="http://........"
            xmlns:c="http://www.springframework.org/schema/c"
             xmlns:xsi="http://.....''>
  <!--  configuration details go here -->
</beans>
```

然后可以使用它了



```csharp
<bean id="cdPlayer" class="soundsystem.CDPlayer"
   c:cd-ref="compactDisc">
//"c:" 命名空间的前缀
//"cd" 构造器参数名
//"-ref"注入bean引用
//"compactDisc" 要注入bean 的ID
```

如果在优化构建的过程,将调试标志移除掉,那么这种方式可能无法正常执行.代替方案



```csharp
<bean id="cdPlayer" class="soundsystem.CDPlayer"
   c:_0-ref="compactDisc">
//把参数名换成"0",也就是参数的索引,但XML中不允许数字作为属性的第一个字符,因此添加下划线"_"
```

如果只有一个参数,根本不用去标示参数



```csharp
<bean id="cdPlayer" class="soundsystem.CDPlayer"
   c:_-ref="compactDisc">
```

##### (2)将字面量注入到构造器中

之前是将对象的引用装配到依赖于它们的其他对象之中,如果有时候,我们需要做的只是用一个字面量值来配置对象.为了阐述这点,创建CompactDisc的一个新的实现



```java
public class BlankDisc implements CompactDisc{
  private String title;
  private String artist;
  
  public BlandDisc(String title,String artist){
    this.title = title;
    this.artist = artist;
  }

  public void paly(){
    System.out.println("Playing"+title+"by"+artist);
  }

}
```

这个于SgtPeppers不同,它可以设置任意想要的title和artist,我们可以已有的SgtPeppers替换为这个类



```jsx
<bean id="compactDisc"
    class="soundysytem.BlankDisc">
  <constructor-arg value="Sgt.Peper's Lonely Hearts" />
  <constructor-arg value="The beatles"/>
</bean>
```

这里再次使用<constructor-arg>元素进行构造器参数的注入,但是没有使用ref属性来引用其他的bean,而是使用了value属性,通过该属性表明给定的值要以字面量的形式注入到构造器之中.

如果要以c-命名空间,可以引用构造器参数名字



```jsx
<bean id="compactDisc"
    class="soundsystem.BlanDisc"
    c:_title="Sgt.Peper's Lonely Hearts"
    c:_artist="The beatles"/>
</bean>
```

可以看到,装配引用和装配字面量的区别在于去掉了-ref后缀,也可以这样通过参数索引



```jsx
<bean id="compactDisc"
    class="soundsystem.BlanDisc"
    c:_0="Sgt.Peper's Lonely Hearts"
    c:_1="The beatles"/>
</bean>
```

##### (3)装配集合



```jsx
<bean id="compactDisc"
    class="soundsystem.BlankDisc">
  <constructor-arg value="Sgt.Peper's Lonely Hearts" />
  <constructor-arg value="The beatles" />
  <constructor-arg>
    <list>
      <value>Sgt. Pepper's Lonely Heats</value>
      <value>With a Little Help</value>
      <value>Lucy in the Sky</value>
      <value>Getting Better</value>
      <value>Fixing a Hole</value>
    </list>
  </constructor-arg>
</bean>
```

也可以使用<ref>元素代替<value>,实现bean引用列表的装配
 假设你有一个Discography类,它的构造器如下



```cpp
public Discography(String artist,List<CompactDisc> cds){...}
```

那么,可以采取如下的方式配置 Discography bean:



```xml
<bean id="beatlesDiscography" class="soundsystem.Discography">
  <constructor-arg value="The Beatles" />
  <constructor-arg>
    <list>
      <ref bean="sgtPeppers" />
      <ref bean="whiteAlbum" />
      ...
    </lsit>
  </constructor-arg>
```

也可以使用<set>元素,set不重复,不能保证顺序,list可以重复,保证顺序



```jsx
<bean id="compactDisc"
    class="soundsystem.BlankDisc">
  <constructor-arg value="Sgt.Peper's Lonely Hearts" />
  <constructor-arg value="The beatles" />
  <constructor-arg>
    <set>
      <value>Sgt. Pepper's Lonely Heats</value>
      <value>With a Little Help</value>
      <value>Lucy in the Sky</value>
      <value>Getting Better</value>
      <value>Fixing a Hole</value>
    </set>
  </constructor-arg>
</bean>
```

##### 3.4设置属性

使用Spring XML实现属性注入,假设属性注入的CDPlayer如下



```java
import soundsystem.CompactDisc;
import soundsystem.MediaPlayer;

public class CDPlayer implements MediaPlayer{
  private CompactDisc compactDisc;

  @Autowired
  public void setCompactDisc(CompactDisc compactDisc){
    this.compactDisc = compactDisc; 
  }

  public void paly(){
    compactDisc.play();
  }
} 
```

注入compactDisc属性



```jsx
<bean id="cdPlayer" class="soundsystem.CDPlayer">
    <property name="compactDisc" ref="compactDisc" />
</bean>
//通过ref引用了ID为compactDisc的bean,将其注入到compactDisc属性中(通过setCompactDisc()方法)
```

使用p-命名空间,先声明



```php
<?xml version="1.0" encoding="UTF-8">
<beans xmlns="http://........"
       xmlns:p="http://www.springframework.org/schema/p"
       xmlns:xsi="http://.....''>
  <!--  configuration details go here -->
</beans>
```

装配



```csharp
<bean id="cdPlayer" class="soundsystem.CDPlayer"
    p:compactDisc-ref="compactDisc" />
</bean>
//"p:" :前缀
//前面的compactDisc: 属性名
//-ref:  注入bean引用
//后面的compactDisc: 所注入bean的ID
```

##### (1)将字面量注入到属性中

新的BlankDisc类如下



```java
public class BlankDisc implements CompactDisc{

  private String title;
  private String artist;
  private List<String> tracks;

   public void setTitel(String title){
    this.title = title;
    }

    public void setArtist(String artist){
      this.artist= artist;
    }
   public void setTracks(List<String> tracks){
    this.tracks= tracks;
    }

    public void play(){
      ....
    }
}
```

使用property元素的value属性实现装配



```xml
<bean id="compactDisc"
      class="soundsystem.BlankDisc">
  <property name="title" value="Sgt.peper's loney hearts club" />
  <property name="artist" value="The Beatles" />
  <property name="tracks">
    <list>
      <value>Sgt.peper's loney hearts club</value>
      <value>loney hearts club</value>
      <value>hearts club</value>
      <value>club hearts</value>
      ...
    </list>
   </property>
```

另一种可选方案就是 用p-命名空间的属性完成



```jsx
<bean id="compactDisc"
      class="soundsystem.BlankDisc"
      p:title="Sgt.peper's loney hearts club"
      p:artist="The Beatles">
  <property name="tracks">
    <list>
      <value>Sgt.peper's loney hearts club</value>
      <value>loney hearts club</value>
      <value>hearts club</value>
      <value>club hearts</value>
      ...
    </list>
   </property>
```

但是,注意,不能用p-空间命名来装配集合,可以使用Spring util -命名空间的一些功能来简化BlankDisc bean
 首先,在XML中声明utli-命名空间及其模式



```php
<?xml version="1.0" encoding="UTF-8">
<beans xmlns="http://........"
            xmlns:c="http://www.springframework.org/schema/c"
            xmlns:util="http://www.springframework.org/schema/util"
             xmlns:xsi="http://.....''>
  <!--  configuration details go here -->
</beans>
```

util-命名空间所提供的功能之一就是<util:list>元素,它会创建一个列表的bean.



```xml
<util:list id="trackList">
     <value>Sgt.peper's loney hearts club</value>
     <value>loney hearts club</value>
     <value>hearts club</value>
     <value>club hearts</value>
</util:lsit>
```

现在,我们能像使用其他的bean一样,把这个列表的bean注入到BlankDisc bean的tracks属性中



```csharp
<bean id="compactDisc"
           class = "soundsystem.BlankDisc"
           p:title="Sgt.pepers lonely hearts"
           p:artist="The Beatles"
           p:tracks-ref="trackList">
```

Spring util-命名空间的元素



```css
<util:constant>  引用某个类型的public static域,并将其暴露给bean
<util:list> 创建一个java.util.List类型的bean,其中包含值或引用
<util:map>创建一个java.util.Map类型的bean,其中包含值或引用
<util:properties>创建一个java.util.Properties类型的bean
<util:property-path> 引用一个bean的属性(或内嵌属性),并将其暴露为bean
<util:set>创建一个java.util.Set类型的bean,其中包含值或引用
```

## Junit

### 问题

1.java.lang.ClassNotFoundException: org.hamcrest.SelfDescribing

修改junit 版本为4.10

2.这两个注解找不到

```java
@ContextConfiguration("classpath:spring-config.xml")
@RunWith(SpringJUnit4ClassRunner.class)
```

添加依赖

```xml
<!-- 添加 spring-test 依赖 -->
<dependency>
  <groupId>org.springframework</groupId>
  <artifactId>spring-test</artifactId>
  <version>${spring.version}</version>
</dependency>
```

spring 整合junit   https://zhuanlan.zhihu.com/p/41664893

## 数据库

### 问题

1.数据库可视化软件sql查询结果不对，尝试刷新一下

2.为什么不用 select *

https://huotublog.com/mysql-why-not-use-select-star/

a）读取不需要的列会增加CPU、IO、NET消耗

b）不能有效的利用覆盖索引

c）使用SELECT *容易在增加或者删除字段后出现程序BUG

3.禁止使用INSERT INTO t_xxx VALUES(xxx)，必须显示指定插入的列属性

解读：容易在增加或者删除字段后出现程序BUG

### 1.增删改查通用代码

### 2. sql

1. 这种查询前端传一个字段，数据库表需要判断两个字段



这种写法效率低 并且无法应用索引？

2.插入数据返回主键id

# 语言

## JAVA

### 

#### Optional

### 注解

注解（Annontion）是Java5开始引入的新特征。它提供了一种安全的类似注释的机制，用来将任何的信息或元数据（metadata）与程序元素（类、方法、成员变量等）进行关联。

#### 元注解

负责注解其他注解。Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。Java5.0定义的元注解有以下几种：

- @Target
- @Retention
- @Documented
- @Inherited

**1.1 @Target**

　　用于描述注解的范围，即注解在哪用。它说明了Annotation所修饰的对象范围：Annotation可被用于 packages、types（类、接口、枚举、Annotation类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数）等。取值类型（ElementType）有以下几种：

1. 　　CONSTRUCTOR:用于描述构造器
2. 　　FIELD:用于描述域即类成员变量
3. 　　LOCAL_VARIABLE:用于描述局部变量
4. 　　METHOD:用于描述方法
5. 　　PACKAGE:用于描述包
6. 　　PARAMETER:用于描述参数
7. 　　TYPE:用于描述类、接口(包括注解类型) 或enum声明
8. 　　TYPE_PARAMETER:1.8版本开始，描述类、接口或enum参数的声明
9. 　　TYPE_USE:1.8版本开始，描述一种类、接口或enum的使用声明

示例：

```
@Target({ElementType.METHOD, ElementType.TYPE})
public @interface Log {
    ......
}
```

上述表示Log注解可以用在类、接口、enum和方法上

**1.2 @Retention**

　　用于描述注解的生命周期，表示需要在什么级别保存该注解，即保留的时间长短。取值类型（RetentionPolicy）有以下几种：

1. 　　SOURCE:在源文件中有效（即源文件保留）
2. 　　CLASS:在class文件中有效（即class保留）
3. 　　RUNTIME:在运行时有效（即运行时保留）

示例：

```
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface Log {
　　......
}
```

上述示例使用RetentionPolicy.RUNTIME，**这样注解处理器可以通过反射，获取到该注解的属性值**，从而去做一些运行时的逻辑处理。

**1.3 @Documented**

　　用于描述其它类型的annotation应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化。它是一个标记注解，没有成员。

示例：

```
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Log {
　　......
}
```

**1.4 @Inherited**

　　用于表示某个被标注的类型是被继承的。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。

 

#### Spring



##### 1.@ComponentScan

该注解默认会扫描该类所在的包下所有的配置类，相当于之前的 <context:component-scan>

#####  2.@RestController

#####  3@RequestBody,@ResponseBody的用法和理解

https://blog.csdn.net/zhanglf02/article/details/78470219

@RequestBody:一般是post请求的时候才会使用这个请求，把参数丢在requestbody里面

#####  4.@PathVariable

spring3.0的一个新功能：接收请求路径中占位符的值 

![image-20210506134225453](C:\Users\yunan10\AppData\Roaming\Typora\typora-user-images\image-20210506134225453.png)

和@RequestParam的区别

@RequestParam和@PathVariable这两者之间区别不大，主要是请求的URL不一样

用@RequestParam请求接口时,URL是:http://www.test.com/user/getUserById?userId=1

用@PathVariable请求接口时,URL是:http://www.test.com/user/getUserById/2



只有一个参数可以省略 value

![image-20210508153708115](C:\Users\yunan10\AppData\Roaming\Typora\typora-user-images\image-20210508153708115.png)

##### 5.校验

数据的校验是交互式网站一个不可或缺的功能，前端的js校验可以涵盖大部分的校验职责，如用户名唯一性，生日格式，邮箱格式校验等等常用的校验。但是为了避免用户绕过浏览器，使用http工具直接向后端请求一些违法数据，服务端的数据校验也是必要的，可以防止脏数据落到数据库中.

######  1.@Validated：加在需要校验的参数

![image-20210507101709179](C:\Users\yunan10\AppData\Roaming\Typora\typora-user-images\image-20210507101709179.png)

######  2.@NotNull    被注释的元素必须不为 null

![image-20210507101805974](C:\Users\yunan10\AppData\Roaming\Typora\typora-user-images\image-20210507101805974.png)

##### @autowire 和@resource的区别和使用场景

Spring通过@Resource注解和@Autowire实现自动装配。

***

@Resource 

根据byName进行装配；默认按名称装配，当找不到与名称匹配的bean时才按照类型进行装配。名称可以通过name属性指定，如果没有指定name属性，当注解写在字段上时，默认取字段名，当注解写在setter方法上时，默认取属性名进行装配。

@Autowire通过byType进行装配；默认按类型装配，默认情况下必须要求依赖对象必须存在，如果要允许null值，可以设置它的required属性为false。

**简要对比表格** 

![img](https://img-blog.csdnimg.cn/2019110413565186.png)


简单理解：

@Autowired 根据类型注入， 	

@Resource 默认根据名字注入，其次按照类型搜索

@Autowired @Qualifie("userService") 两个结合起来可以根据名字和类型注入

复杂理解：

```java
@Service(“UserService”)
public Class UserServiceImpl implements UserService{
}
```

* @Autowired :当使用这个注入的时候上面的 UserServiceImpl 只需要这样写 @Service，这样就会自动找到UserService这个类型以及他的子类型.

​       缺点：当UserService实现类有两个以上的时候会造成冲突，所以要用@AutoWire注入的时候要确保UserService只有一个实现类。

* @Resource ：

默认情况下是按照名称进行匹配，如果没有找到相同名称的Bean，则会按照类型进行匹配，有人可能会想了，这下好了，用这个是万能的了，不用管名字了，也不用管类型了，但这里还是有缺点。首先，根据这个注解的匹配效果可以看出，它进行了两次匹配，也就是说，如果你在UserService这个类上面这样写注解，@Service,它会怎么找呢，首先是找相同名字的，如果没有找到，再找相同类型的，而这里的@Service没有写名字，这个时候就进行了两次搜索，显然，速度就下降了许多。也许你还会问，这里的@Service本来就没有名字，肯定是直接进行类型搜索啊。其实不是这样的，UserServiceImpl 上面如果有@Service默认的名字 是这个userServiceImpl，注意看，就是把类名前面的大写变成小写，就是默认的Bean的名字了。 @Resource根据名字搜索是这样写@Resource("userService")，如果你写了这个名字叫userService，那么UserServiceImpl上面必须也是这个名字，不然还是会报错。

@Autowired @Qualifie("userService") 是直接按照名字进行搜索，也就是说，对于UserServiceImpl 上面@Service注解必须写名字，不写就会报错，而且名字必须是@Autowired @Qualifie("userService") 保持一致。如果@Service上面写了名字，而@Autowired @Qualifie() ，一样会报错。

private UserService userService;

}

说了这么多，可能你有些说晕了，那么怎么用这三个呢，要实际的工作是根据实际情况来使用的，通常使用AutoWire和@Resource多一些，bean的名字不用写，而UserServiceImpl上面能会这样写 @Service("userService")。这里的实际工作情况，到底是什么情况呢？说白了就是整个项目设计时候考虑的情况，如果你的架构设计师考虑的比较精细，要求比较严格，要求项目上线后的访问速度比较好，通常是考虑速度了。这个时候@AutoWire没有@Resource好用，因为@Resource可以根据名字来搜索，是这样写的@Resource("userService")。这个@Autowired @Qualifie("userService") 也可以用名字啊，为什么不用呢，原因很简单，这个有点长，不喜欢，增加工作量。因为根据名字搜索是最快的，就好像查数据库一样，根据Id查找最快。因为这里的名字与数据库里面的ID是一样的作用。这个时候，就要求你多写几个名字，工作量自然就增加了。而如果你不用注解，用xml文件的时候，对于注入Bean的时候要求写一个Id，xml文件时候的id就相当于这里的名字。

说了那么多没用，你能做的就是简单直接，什么最方便就用什么，

你就直接用@Resource得了，如果你喜欢用@AutoWire也行，不用写名字。

通常情况一个Bean的注解写错了，会报下面这些错误，最为常见，

No bean named 'user' is defined，这个表示没有找到被命名为user的Bean，通俗的说，就是名字为user的类型，以及它的子类型，出现这个错误的原因就是注入时候的类型名字为user，而搜索的时候找不到，也就是说可能那个搜索的类型，并没有命令为user，解决办法就是找到这个类型，去命令为user，

下面这个错误也常见，

No qualifying bean of type [com.service.UserService] found for dependency:

这个错误的原因就是类型上面没有加@Service这个注入，不仅仅是@Service，如果是其他层也会出现这个错误，这里我是以Service为例子说明，如果是DAO层就是没有加@Repository，Controller层，则是没有加@Controller。

还有，如果你还是想再简单点，无论是DAO,Controller，Service三个层，都可以用这个注解，@Component，这个注解通用所有的Bean，这个时候你可能会说了，有通常的为什么用的人少呢，那是因为MVC这个分层的设计原则，用@Repository,@Service，@Controller，这个可以区别MVC原则中的DAO,Service，Controller。便于识别。

 

@Autowired 注释进行自动注入时，Spring 容器中匹配的候选 Bean 数目必须有且仅有一个。当找不到一个匹配的 Bean 时，Spring 容器将抛出 BeanCreationException 异常，并指出必须至少拥有一个匹配的 Bean。

@Autowired 默认是按照byType进行注入的，如果发现找到多个bean，则，又按照byName方式比对，如果还有多个，则报出异常。

例子：

@Autowired
private ExamUserMapper examUserMapper;  - ExamUserMapper是一个接口

1. spring先找类型为ExamUserMapper的bean

2. 如果存在且唯一，则OK；

3. 如果不唯一，在结果集里，寻找name为examUserMapper的bean。因为bean的name有唯一性，所以，到这里应该能确定是否存在满足要求的bean了

@Autowired也可以手动指定按照byName方式注入，使用@Qualifier标签，例如：

@Autowired () @Qualifier ( "baseDao" )

@Qualifier 注释指定注入 Bean 的名称，这样歧义就消除了，可以通过下面的方法解决异常。 

@Qualifier("XXX") 中的 XX是 Bean 的名称，所以 @Autowired 和 @Qualifier 结合使用时，自动注入的策略就从 byType 转变成 byName 了。 

@Autowired 可以对成员变量、方法以及构造函数进行注释，而 @Qualifier 的标注对象是成员变量、方法入参、构造函数入参。 
Spring不但支持自己定义的@Autowired注解，还支持几个由JSR-250规范定义的注解，它们分别是@Resource、@PostConstruct以及@PreDestroy。 

@Resource 的作用相当于@Autowired，只不过@Autowired按byType自动注入，而@Resource默认按 byName自动注入罢了。@Resource有两个属性是比较重要的，分是name和type，Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略。 

@Resource装配顺序 

  　　1. 如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常 
        　　2. 如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常 
              　　3. 如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常 
                    　　4. 如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配

### 问题

### 1.Java对象序列化与反序列化

##### 序列化与反序列化

序列化是将对象的状态信息转换为可以存储或传输的形式的过程。一般将一个对象存储至一个储存媒介，例如档案或是记亿体缓冲等。在网络传输过程中，可以是字节或是XML等格式。而字节的或XML编码格式可以还原完全相等的对象。这个相反的过程又称为反序列化。

##### Java对象的序列化与反序列化：

在Java中，我们可以通过多种方式来创建对象，并且只要对象没有被回收我们都可以复用该对象。但是，我们创建出来的这些Java对象都是存在于JVM的堆内存中的。只有JVM处于运行状态的时候，这些对象才可能存在。一旦JVM停止运行，这些对象的状态也就随之而丢失了。

但是在真实的应用场景中，我们需要将这些对象持久化下来，并且能够在需要的时候把对象重新读取出来。Java的对象序列化可以帮助我们实现该功能。

对象序列化机制（object seialization）是Java语言内建的一种对象持久化方式，通过对象序列化，可以把对象的状态保存为字节数组，并且可以在有需要的时候将这个字节数组通过反序列化的方式再转换成对象。对象序列化可以很容易的在JVM中的活动对象和字节数组（流）之间进行转换。

在Java中，对象的序列化与反序列化被广泛应用到RMI(远程方法调用)及网络传输中。

##### 相关接口及类

Java为了方便开发人员将Java对象进行序列化及反序列化提供了一套方便的API来支持。其中包括以下接口和类：

``` java
java.io.Serializable
java.io.Externalizable
ObjectOutput
ObjectInput
ObjectOutputStream
ObjectInputStream
```

##### Serializable 接口

**类通过实现 `java.io.Serializable` 接口以启用其序列化功能。未实现此接口的类将无法使其任何状态序列化或反序列化。**可序列化类的所有子类型本身都是可序列化的。**序列化接口没有方法或字段，仅用于标识可序列化的语义。**

当试图对一个对象进行序列化的时候，如果遇到不支持 Serializable 接口的对象。在此情况下，将抛出 `NotSerializableException`。

虽然Serializable接口中并没有定义任何属性和方法，但是如果一个类想要具备序列化能力也比必须要实现它。其实，主要是因为序列化在真正的执行过程中会使用instanceof判断一个类是否实现类Serializable，如果未实现则直接抛出异常。

如果要序列化的类有父类，要想同时将在父类中定义过的变量持久化下来，那么父类也应该集成`java.io.Serializable`接口。

下面是一个实现了`java.io.Serializable`接口的类

```package com.hollischaung.serialization.SerializableDemos;
import java.io.Serializable;

public class User1 implements Serializable {
   private String name;
   private int age;
   public String getName() {
       return name;
   }
   public void setName(String name) {
       this.name = name;
   }
   public int getAge() {
       return age;
   }
   public void setAge(int age) {
       this.age = age;
   }
   @Override
   public String toString() {
       return "User{" +
               "name='" + name + '\'' +
               ", age=" + age +
               '}';
   }
}

通过下面的代码进行序列化及反序列化

​```java
package com.hollischaung.serialization.SerializableDemos;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;

/**
* SerializableDemo1 结合SerializableDemo2说明 一个类要想被序列化必须实现Serializable接口
*/
public class SerializableDemo1 {

   public static void main(String[] args) {
       //Initializes The Object
       User1 user = new User1();
       user.setName("hollis");
       user.setAge(23);
       System.out.println(user);

       //Write Obj to File
       try (FileOutputStream fos = new FileOutputStream("tempFile"); ObjectOutputStream oos = new ObjectOutputStream(
           fos)) {
           oos.writeObject(user);
       } catch (IOException e) {
           e.printStackTrace();
       }

       //Read Obj from File
       File file = new File("tempFile");
       try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file))) {
           User1 newUser = (User1)ois.readObject();
           System.out.println(newUser);
       } catch (IOException | ClassNotFoundException e) {
           e.printStackTrace();
       }
   }
}

//OutPut:
//User{name='hollis', age=23}
//User{name='hollis', age=23}
```



如果你观察够细微的话，你可能会发现，我在上面的测试代码中使用了IO流，但是我并没有显示的关闭他。这其实是Java 7中的新特性try-with-resources。这其实是Java中的一个语法糖，背后原理其实是编译器帮我们做了关闭IO流的工作。后面我会单独出一篇文章介绍下如何使用语法糖提高代码质量。

上面的代码中，我们将代码中定义出来的User对象通过序列化的方式保存到文件中，然后再从文件中将他到序列化成Java对象。结果是我们的对象的属性均被持久化了下来。

##### Externalizable接口

除了Serializable 之外，java中还提供了另一个序列化接口`Externalizable`

为了了解Externalizable接口和Serializable接口的区别，先来看代码，我们把上面的代码改成使用Externalizable的形式。

```java
package com.hollischaung.serialization.ExternalizableDemos;

import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;

/**
* 实现Externalizable接口
*/
public class User1 implements Externalizable {

   private String name;
   private int age;

   public String getName() {
       return name;
   }
   public void setName(String name) {
       this.name = name;
   }
   public int getAge() {
       return age;
   }
   public void setAge(int age) {
       this.age = age;
   }
   public void writeExternal(ObjectOutput out) throws IOException {

   }
   public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {

   }
   @Override
   public String toString() {
       return "User{" +
               "name='" + name + '\'' +
               ", age=" + age +
               '}';
   }
}
```

```java
package com.hollischaung.serialization.ExternalizableDemos;

import java.io.*;

/**
* 对一个实现了Externalizable接口的类进行序列化及反序列化
*/
public class ExternalizableDemo1 {

  public static void main(String[] args) {
      //Write Obj to file
      User1 user = new User1();
      user.setName("hollis");
      user.setAge(23);
      try(ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("tempFile"))){
          oos.writeObject(user);
      } catch (IOException e) {
          e.printStackTrace();
      }

      //Read Obj from file
      File file = new File("tempFile");
      try(ObjectInputStream ois =  new ObjectInputStream(new FileInputStream(file))){
          User1 newInstance = (User1) ois.readObject();
          //output
          System.out.println(newInstance);
      } catch (IOException | ClassNotFoundException e ) {
          e.printStackTrace();
      }
  }
}
//OutPut:
//User{name='null', age=0}
```

可以发现，对User1类进行序列化及反序列化之后得到的对象的所有属性的值都变成了默认值。也就是说，之前的那个对象的状态并没有被持久化下来。这就是Externalizable接口和Serializable接口的区别：

Externalizable继承了Serializable，该接口中定义了两个抽象方法：writeExternal()与readExternal()。当使用Externalizable接口来进行序列化与反序列化的时候需要开发人员重写writeExternal()与readExternal()方法。

由于上面的代码中，并没有在这两个方法中定义序列化实现细节，所以输出的内容为空。还有一点值得注意：**在用Externalizable进行序列化的时候，在读取对象时，会调用被序列化类的无参构造器去创建一个新的对象，然后再将被保存对象的字段的值分别填充到新对象中。所以，实现Externalizable接口的类必须要提供一个public的无参的构造器。**

如果实现了Externalizable接口的类中没有无参数的构造函数，在运行时会抛出异常：java.io.InvalidClassException。如果一个Java类没有定义任何构造函数，编译器会帮我们自动添加一个无参的构造方法，可是，如果我们在类中定义了一个有参数的构造方法了，编译器便不会再帮我们创建无参构造方法，这点需要注意。

按照要求修改之后代码如下：

```java
package com.hollischaung.serialization.ExternalizableDemos;

import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;

/**
* 实现Externalizable接口,并实现writeExternal和readExternal方法
*/
public class User2 implements Externalizable {

   private String name;
   private int age;

   public String getName() {
       return name;
   }
   public void setName(String name) {
       this.name = name;
   }
   public int getAge() {
       return age;
   }
   public void setAge(int age) {
       this.age = age;
   }
   public void writeExternal(ObjectOutput out) throws IOException {
       out.writeObject(name);
       out.writeInt(age);
   }
   public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
       name = (String) in.readObject();
       age = in.readInt();
   }

   @Override
   public String toString() {
       return "User{" +
               "name='" + name + '\'' +
               ", age=" + age +
               '}';
   }
}
```

再执行测试得到以下结果

```java
//OutPut:
//User{name='hollis', age=23}
```

这次，就可以把之前的对象状态持久化下来了。

##### ObjectOutput和ObjectInput 接口

上面的writeExternal方法和readExternal方法分别接收ObjectOutput和ObjectInput类型参数。这两个类作用如下。

***

ObjectInput 扩展自 DataInput 接口以包含对象的读操作。

DataInput 接口用于从二进制流中读取字节，并根据所有 Java 基本类型数据进行重构。同时还提供根据 UTF-8 修改版格式的数据重构 String 的工具。

对于此接口中的所有数据读取例程来说，如果在读取所需字节数之前已经到达文件末尾 (end of file)，则将抛出 EOFException（IOException 的一种）。如果因为到达文件末尾以外的其他原因无法读取字节，则将抛出 IOException 而不是 EOFException。尤其是，在输入流已关闭的情况下，将抛出 IOException。

***

ObjectOutput 扩展 DataOutput 接口以包含对象的写入操作。

DataOutput 接口用于将数据从任意 Java 基本类型转换为一系列字节，并将这些字节写入二进制流。同时还提供了一个将 String 转换成 UTF-8 修改版格式并写入所得到的系列字节的工具。

对于此接口中写入字节的所有方法，如果由于某种原因无法写入某个字节，则抛出 IOException。

##### ObjectOutputStream、ObjectInputStream类

通过前面的代码片段中我们也能知道，我们一般使用ObjectOutputStream的`writeObject`方法把一个对象进行持久化。再使用ObjectInputStream的`readObject`从持久化存储中把对象读取出来。

##### transient 关键字

transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。

##### 序列化ID

虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致（就是 `private static final long serialVersionUID`)

序列化 ID 在 Eclipse 下提供了两种生成策略，一个是固定的 1L，一个是随机生成一个不重复的 long 类型数据（实际上是使用 JDK 工具生成），在这里有一个建议，如果没有特殊需求，就是用默认的 1L 就可以，这样可以确保代码一致时反序列化成功。那么随机生成的序列化 ID 有什么作用呢，有些时候，通过改变序列化 ID 可以用来限制某些用户的使用。

## Vim

### 1.问题

1.非正常关闭文件

方法1 vim -r .conf恢复以后把.swap文件删掉，在打开时就不会用提示良，注意.swap文件是个隐藏文件。可用：la查看。以.开头的是隐藏文件。

方法2 ls -a 查询隐藏文件 将后缀名为.swp的文件删除rm -f .nginx.conf.swp 再次编辑文件不在出现提示警告！



# 中间件

## ES

[]: https://learnku.com/docs/elasticsearch73/7.3/data-in-documents-and-indices/6446

# 设计模式

## 简单工厂

1.实现一个计算器功能

```java
public class Calcultor {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.println("请输入数字A：");
        String A = sc.nextLine();
        System.out.println("请输入运算符号（+ - * / ）：");
        String operator = sc.nextLine();
        System.out.println("请输入数字B：");
        String B = sc.nextLine();
        double res = 0;

        if ("+".equals(operator)){
            res = Double.valueOf(A) + Double.valueOf(B);
        }
        if ("-".equals(operator)){
            res = Double.valueOf(A) - Double.valueOf(B);
        }
        if ("*".equals(operator)){
            res = Double.valueOf(A) * Double.valueOf(B);
        }
        if ("/".equals(operator)){
            res = Double.valueOf(A) / Double.valueOf(B);
        }
        System.out.println(res);
    }
}
```

 变量需要命名规范,  if每条都要判断，除数为0怎么办(double数字类型可以是 Infinity)

```java
public class Calcultor {
    public static void main(String[] args) {
        try{
            Scanner sc = new Scanner(System.in);
            System.out.println("请输入数字A：");
            String numberA = sc.nextLine();
            System.out.println("请输入运算符号（+ - * / ）：");
            String operator = sc.nextLine();
            System.out.println("请输入数字B：");
            String numberB = sc.nextLine();
            double res = 0;

            switch (operator){
                case "+" : res = Double.valueOf(numberA) + Double.valueOf(numberB); break;
                case "-" : res = Double.valueOf(numberA) - Double.valueOf(numberB); break;
                case "*" : res = Double.valueOf(numberA) * Double.valueOf(numberB); break;
                case "/" : res = Double.valueOf(numberA) / Double.valueOf(numberB); break;
            }

            System.out.println(res);
        }catch(Exception e) {
            System.out.println("输入参数有误");
        }
    }
}
```

此时都是面向国策

# 京东技术学习

[]: https://l.jd.com/student/project/project.du?project_id=220783196

藏金阁技术分享  

[]: https://cf.jd.com/pages/viewpage.action?pageId=434868374

推荐好文章 ：https://developer.ibm.com/zh/articles/j-lo-hotswapcls/

技术文档规范 http://tp-tech.jd.com/tech-specification/entrance/1.sdk.html

mysql  数据库开发规范  http://tigcms.jd.com/details/ryG-r2dM7.html

《京东信息安全事件响应规范》http://anquan.jd.com/#/rulepdfview/1

研发各阶段注意事项  https://cf.jd.com/pages/viewpage.action?pageId=340134379

jmq 和 jsf 的
https://cf.jd.com/pages/viewpage.action?pageId=245188427

https://cf.jd.com/pages/viewpage.action?pageId=245185287

## 京东预发线上数据库

1.申请

http://dbsv4.jd.com/workflow;jsessionid=714D8C85EB10B0CB0588152E5B3E0863.s1?jumpMenu=/workflow/AutoDbOnlineOpt

2.插入数据提示表名不存在

insert into  库名.表名

可能不支持库名.表名  库名去掉即可

618大促 峰值 一分钟90万    mq 积压22万

# 待查

1. 内部类不能被外部访问？
2. 基本类型不能有set get方法？
3. 3.泛型？

1. ctrl+shift+f 和搜狗冲突

2. @RestController


```
@WebAppConfiguration
```

https://www.zhihu.com/question/300830746

响尾蛇  阿里巴巴开源

@Page怎么搞的？

idea  maven  tomcat插件怎么支持热部署

@EnumValid 怎么搞的

  2. 什么是防腐层
 4. if 嵌套太多   可以加 if里面加 return  else就可以去掉了
 5. 不关心的代码可以往出移

循环单条插入和  batchinsert  哪个效率高

过滤垃圾邮件

通知

问问向辉 猴子捣乱 有无文档什么的 了解全链路。 大促 整个链路是怎么打通的

了解 s q l 优化知识 ēxplain 关键字

透传



# 前端

## 问题

1.<img src=""> 不显示图片

可能是resource 文件夹没有标记成Sources Root，图片名称不要用中文名

![image-20210319110051702](C:\Users\yunan10\AppData\Roaming\Typora\typora-user-images\image-20210319110051702.png)

./ 表示当前路径   ../表示上层   ../../表示上上层  ../../../  依次类推

3. 画框的地方隐藏掉

![image-20210319141342314](C:\Users\yunan10\AppData\Roaming\Typora\typora-user-images\image-20210319141342314.png)

![image-20210319141351199](C:\Users\yunan10\AppData\Roaming\Typora\typora-user-images\image-20210319141351199.png)



```html
<span style="display:none"><input type="file" accept="image/*" name="file" id="businessLicensePicUrl"/></span>
```

4.后端传数据，js怎么解析

如果报undefined    var obj = JSON.parse(result);    解析下  然后obj.属性

### 

## 问题

1.外接鼠标滚轮卡顿

下载smooth scroll 

2.idea卡顿  鼠标转圈



1.怎么充分理解业务需求？prd评审有哪些常问的套路

2.以后调研一个东西，应该更关注它的缺点



零售大力发展Pass化，费了很大力气主战切量。为了以后共建。





